%% LaBGAS_1_spm_prep_firstlvl_models
%
% This script generates a CANlab style first level DSGN structure array and
% CANlab/spm style onset/duration and noise regressor files
%
% See canlab_glm_single_subject('dsgninfo'), or documentation in 
% Github\CanlabCore\CanlabCore\GLM_Batch_tools for details on first level
% analysis using CANlab tools
%
% This script is adapted by @lukasvo76 from the scripts
% 1) 1_spm_fit_firstlvl_models.m and 1_spm_prep_single_trial_models.m
% by @bogpetre on 
% Google Drive\CANlab\CANLAB Lab Member Documents\GLM_batch_tools\bogdan_paingen
% 2) MPA2_set_design_model1_blanca.m by @martaceko on
% Google Drive\CANlab\CANLAB Lab Member Documents\GLM_batch_tools\
% Marta_MPA2\MPA2code_1stlevel\Code
% contact @lukasvo76 if you need those original scripts
%
% DEPENDENCIES ON YOUR MATLAB PATH
% a) SPM12
% b) CANlab tools cloned from Github (see canlab.github.io)
% 
% INPUTS 
% 1. [if noise_method = LaBGAS] 
% noise_regs.txt and onsets.mat files in derivatives\fmriprep\sub-[0-9][0-9]\func
% generated by LaBGAS_extract_confound_reg_fMRIprep.m
% OR [if noise_method = CANlab] 
% desc_confounds_regressors.tsv output from fMRIprep
% 2. smoothed fMRIprepped files generated by
% LaBGAS_deriv_unzip_nii_smooth.m
%
% OUTPUT
% 1. CANlab style first level DSGN structure array
% 2. CANlab/spm style onset/duration and noise regressor files
% these can be used to fit first level models using
% LaBGAS_2_spm_fit_firstlvl_models.m
%
% useAROMA
% set to true if you want to use ICA-AROMA for removing motion artefacts
% https://pubmed.ncbi.nlm.nih.gov/25770991/
% ONLY POSSIBLE IF --use-AROMA OPTION WAS USED IN FMRIPREP
% NEEDS TO BE TESTED BY LUKAS BEFORE IMPLEMENTATION
% WILL ONLY WORK IF NOISE_METHOD = CANlab - see below
%
% noise_method
% case insensitive as strcmpi function is used rather than strcmp
% 'LaBGAS' 
% uses noise_regs.txt files generated by 
% LaBGAS_extract_confound_reg_fMRIprep.m
% 'CANlab'
% calculates derivatives and quadratic terms of 6
% realignement parameters from fMRIprep output files as part of this
% script, and takes spike regressors from fMRIprep output
% This option does basically the same as the spike_def = 'CANlab' option in
% LaBGAS_extract_confound_reg_fMRIprep.m; we may get rid of that redundancy
% in the workflow in the future
% USE THIS OPTION IF YOU WANT TO USE ICA-AROMA
%
% maskTRs
% number of initial volumes you want to mask/regress out
% this is an option built in by @bogpetre which we typically don't use/need
% @LaBGAS since our Philips scanner starts with 4 dummies before the first
% actual volume, which are not saved
% NEEDS TO BE TESTED BY LUKAS BEFORE IMPLEMENTATION
%
% conds2model
% enter cell array with names of conditions you want to
% include in your first level model
% NAMES AND ORDER NEED TO CORRESPOND WITH DSGN.conditions created by 
% LaBGAS_get_firstlvl_dsgn_obj.m
%__________________________________________________________________________
%
% authors: 
% lukas.van.oudenhove@dartmouth.edu, lukas.vanoudenhove@kuleuven.be
% bogdan.petre@dartmouth.edu,
% marta.ceko@colorado.edu
%
% date:   October, 2020
%
%__________________________________________________________________________
% @(#)% LaBGAS_1_spm_prep_firstlvl_models.m         v1.1        
% last modified: 2021/02/09
%
%% settings

% addpath(genpath('C:\Users\lukas\Documents\GitHub\CanlabCore')); % add relevant CANlab tools folders and spm to Matlab path if they are not there yet
% addpath(genpath('C:\Users\lukas\Documents\GitHub\CanlabPrivate'));
% addpath(genpath('C:\Users\lukas\Documents\MATLAB\spm12'));
addpath(genpath('C:\Users\lukas\Documents\GitHub\proj-emosymp')); % add the LaBGAS Github repo for this project

DSGN = LaBGAS_get_firstlvl_dsgn_obj(); % calls function to write DSGN structure array to your Matlab workspace
useAROMA = false; % set to true if you want to use ICA-AROMA
noise_method = 'canlab';
maskTRs = 0;
conds2model = {'negative','neutral','positive','pause','rating'}; % cell array with names of conditions you want to model - see documentation above

%% extract model data, perform sanity check and save it
% @bogpetre: serial processing because invoking 'save' in parallel requires
% inelegant hacks
for i = 1:2 % iter over subj
    for j = 1:size(DSGN.funcnames,2)
    nii = dir([DSGN.subjects{i},'\',DSGN.funcnames{j}]);
        if ~isempty(nii) % if has nii
            onset_file=ls([nii(1).folder,'\onset*']);
            save_files = true;    
            nii_path = [nii(1).folder, '\', nii(1).name];
            sid = nii(1).name(4:16);
            nii_hdr = read_hdr(nii_path); % used later for sanity checks

            %% create onsets vector design
            % define and load onsets file generated by LaBGAS_extract_confound_reg_fMRIprep.m     
            try 
                stim_dat = importdata([nii(1).folder,'\',onset_file(1,:)]); % in our case, this generates a table variable, which is great!
            catch
                error(['Could not import onset data for ' nii_path]);
            end
            
            % initialize structure for each condition
            % this is study-specific and currently still partly hard-coded!
            negative = struct('name',{conds2model(1)}, ...
                        'onset', {{[]}}, ...
                        'duration', {{[]}});
            neutral = struct('name',{conds2model(2)}, ...
                            'onset', {{[]}}, ...
                            'duration', {{[]}});
            positive = struct('name',{conds2model(3)}, ...
                            'onset', {{[]}}, ...
                            'duration', {{[]}});
            pause = struct('name',{conds2model(4)}, ...
                            'onset', {{[]}}, ...
                            'duration', {{[]}});
            rating = struct('name',{conds2model(5)}, ...
                        'onset', {{[]}}, ...
                        'duration', {{[]}});
            
            % initialize SPM style design obj
            for k = 1:size(stim_dat.trial_type,1)
                switch stim_dat.trial_type(k)
                    case 'negative'
                        negative.onset{1} = [negative.onset{1}, stim_dat.onset(k)];
                        negative.duration{1} = [negative.duration{1}, stim_dat.duration(k)];
                    case 'neutral'
                        neutral.onset{1} = [neutral.onset{1}, stim_dat.onset(k)];
                        neutral.duration{1} = [neutral.duration{1}, stim_dat.duration(k)];
                    case 'positive'
                        positive.onset{1} = [positive.onset{1}, stim_dat.onset(k)];
                        positive.duration{1} = [positive.duration{1}, stim_dat.duration(k)];
                    case 'pause'
                        pause.onset{1} = [pause.onset{1}, stim_dat.onset(k)];
                        pause.duration{1} = [pause.duration{1}, stim_dat.duration(k)];
                    case 'rating'
                        rating.onset{1} = [rating.onset{1}, stim_dat.onset(k)];
                        rating.duration{1} = [rating.duration{1}, stim_dat.duration(k)];
                end
            end
                      
            %% create noise vector design
            if strcmpi(noise_method,'CANlab')==1
                noise_tsv = dir([nii(1).folder,'\*desc-confounds_timeseries.tsv']);
                try
                    fid = fopen([noise_tsv(1).folder,'\',noise_tsv(1).name]);
                    noise_hdr = strsplit(fgetl(fid));
                    noise_dat = textscan(fid,[repmat('%f',1,length(noise_hdr))],...
                        'Delimiter',{'\t',' '},...
                        'MultipleDelimsAsOne',1,'ReturnOnError',false,...
                        'CollectOutput',1,'TreatAsEmpty','n/a','EndOfLine','\n');
                    for m = 1:size(noise_dat{1},2)
                        this_col = noise_dat{1}(:,m);
                        noise_dat{1}(isnan(this_col),m) = nanmean(this_col); % replaces NaNs with column mean
                    end
                    fclose(fid);
                catch
                    warning(sprintf('Could not import confounds for %s, skipping...\n',...
                        [nii(1).folder,'/*desc-confounds_regressors.tsv']));
                    save_files = false;
                end

                noiseCol = {'csf','trans_x','trans_y','trans_z','rot_x','rot_y','rot_z'};

                if useAROMA % needs testing on dataset with aroma columns
                    aromaCol = cellfun(@(x1)(logical(any(x1))),strfind(noise_hdr,'aroma'));
                    noiseCol = [noiseCol, noise_hdr{aromaCol}];
                    quadCol = noiseCol(~contains(noiseCol,aromaCol));
                    SR = []; %disable spike correction when using ICA-AROMA
                else
                    quadCol = noiseCol;
                    cd(nii(1).folder);
                    [g, spikes, gtrim, nuisance_covs] = scn_session_spike_id(nii_path,'doplots',1);
                end

                % note that this variable MUST be called R for canlab glm tools (or actually the SPM tools they 
                % invoke) to work
                R = noise_dat{1}(:,endsWith(noise_hdr,noiseCol)); % extracts csf (column 1), translation parms (column 2-4), and rotation parms (column 5-7) from fmriprep confounds_regressors file
                R = R - mean(R); % demean

                % compute derivatives using Matlab's diff function
                dR = diff(noise_dat{1}(:,endsWith(noise_hdr,noiseCol)));
                dR = [zeros(1,size(dR,2));dR]; % adds a first line of zeros

                % compute quadratic terms
                % we don't want quadratics of AROMA terms, but we want
                % everything else
                % demeaning doesn't affect coefficient estimates because
                % quadratic fits are driven by extrema, and for extrema 
                % (xi - mean(x))^2 ~ xi^2, but it helps with scaling for data
                % with inconvenient baselines like BOLD measures.
                RR = noise_dat{1}(:,endsWith(noise_hdr,quadCol)); 
                R = [R, dR, (RR - mean(RR)).^2, dR.^2];
                R = R - mean(R);

                % check that noise_dat length matches number of TRs in nifti file
                if nii_hdr.tdim ~= size(R,1)
                    warning(['noise data length (', int2str(size(R,1)),...
                        ') does not match nifti TR length (', int2str(nii_hdr.tdim), '), skipping...']);
                end
                
                % add spike columns (and early volumes) to R
                SR = nuisance_covs(:,2:end); % first column is global signal, exclude that
                earlyVol = zeros(nii_hdr.tdim, maskTRs);
                    for k = 1:maskTRs
                        earlyVol(k,k) = 1;
                        % some of these may have been flagged as spikes, if so
                        % remove them
                        if ~isempty(spikes)
                            covs = corr(earlyVol(:,k),spikes);
                            if any(covs == 1)
                                spikes(:,covs == 1) = [];
                            end
                        end
                end
                R = [R, earlyVol, SR];
                
            elseif strcmpi(noise_method,'LaBGAS')==1
                noise_tsv = dir([nii(1).folder,'\noise_regs*.txt']);
                R=readtable([noise_tsv(1).folder,'\',noise_tsv(1).name],'FileType', 'text', 'Delimiter', 'tab');
                R=table2array(R);
                
            else
                error('invalid noise_method option');
            end
            
            % do a sanity check on design info
            maxDesignTiming = max([negative.onset{1} + negative.duration{1}, neutral.onset{1} + neutral.duration{1}, positive.onset{1} + positive.duration{1}, pause.onset{1} + pause.duration{1}, rating.onset{1} + rating.duration{1}]);
            boldDuration = nii_hdr.tdim*DSGN.tr;
            if boldDuration < maxDesignTiming
                warning(['Max stimulus timing (' int2str(maxDesignTiming) 's) exceeds BOLD duration (' int2str(boldDuration) ,'s) for ' sid ' run ' int2str(j), ', skipping ...']);
                save_files = false;
            end
            
            % save files if sanity checks are passed
            if save_files
                mkdir(nii(1).folder,DSGN.modelingfilesdir)
                mdl_path = [nii(1).folder, '\', DSGN.modelingfilesdir, '\'];
                save([mdl_path, negative.name{1}],'-struct','negative');
                save([mdl_path, neutral.name{1}],'-struct','neutral');
                save([mdl_path, positive.name{1}],'-struct','positive');
                save([mdl_path, pause.name{1}],'-struct','pause');
                save([mdl_path, rating.name{1}],'-struct','rating');

                save([mdl_path, DSGN.multireg, '.mat'],'R');
            end
        else
            subject=DSGN.subjects{i};
            warning(strcat('missing run_',num2str(j),' in subject_',subject));
        end
    end
end
